"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var dgeni_1 = require("dgeni");
var mockPackage = require('../../mocks/mockPackage');
var path = require('canonical-path');
describe('readTypeScriptModules', function () {
    var dgeni;
    var injector;
    var processor;
    beforeEach(function () {
        dgeni = new dgeni_1.Dgeni([mockPackage()]);
        injector = dgeni.configureInjector();
        processor = injector.get('readTypeScriptModules');
        processor.basePath = path.resolve(__dirname, '../../mocks/readTypeScriptModules');
    });
    describe('exportDocs', function () {
        it('should extract all content from the comments', function () {
            processor.sourceFiles = ['commentContent.ts'];
            var docs = [];
            processor.$process(docs);
            var someClassDoc = docs.find(function (doc) { return doc.name === 'SomeClass'; });
            expect(someClassDoc.content).toEqual('@empty');
            var fooDoc = docs.find(function (doc) { return doc.name === 'foo'; });
            expect(fooDoc.content).toEqual('The description\n@tag1\ntag info');
            var barDoc = docs.find(function (doc) { return doc.name === 'bar'; });
            expect(barDoc.content).toEqual('@name bar\n@description\ndescription of bar {@inline-tag} more content');
        });
        it('should extract the starting and ending lines from the comments', function () {
            processor.sourceFiles = ['commentContent.ts'];
            var docs = [];
            processor.$process(docs);
            var someClassDoc = docs.find(function (doc) { return doc.name === 'SomeClass'; });
            expect(someClassDoc.startingLine).toEqual(0);
            expect(someClassDoc.endingLine).toEqual(17);
            var fooDoc = docs.find(function (doc) { return doc.name === 'foo'; });
            expect(fooDoc.startingLine).toEqual(4);
            expect(fooDoc.endingLine).toEqual(9);
            var barDoc = docs.find(function (doc) { return doc.name === 'bar'; });
            expect(barDoc.startingLine).toEqual(10);
            expect(barDoc.endingLine).toEqual(16);
        });
        it('should provide the original module if the export is re-exported', function () {
            processor.sourceFiles = ['publicModule.ts'];
            var docs = [];
            processor.$process(docs);
            var exportedDoc = docs[1];
            expect(exportedDoc.originalModule).toEqual('privateModule');
        });
        it('should include exported abstract classes', function () {
            processor.sourceFiles = ['publicModule.ts'];
            var docs = [];
            processor.$process(docs);
            var exportedDoc = docs[2];
            expect(exportedDoc.name).toEqual('AbstractClass');
        });
        it('should hide members marked as private in TypeScript', function () {
            processor.sourceFiles = ['privateMembers.ts'];
            var docs = [];
            processor.$process(docs);
            expect(docs.every(function (doc) { return doc.name !== 'privateProperty'; })).toBe(true);
        });
        it('should put static members into the `.statics` property of the export doc', function () {
            processor.sourceFiles = ['staticMembers.ts'];
            var docs = [];
            processor.$process(docs);
            var classDoc = docs.find(function (doc) { return doc.docType === 'class'; });
            expect(classDoc.statics.length).toEqual(2);
            expect(classDoc.statics.map(function (staticMember) { return staticMember.name; })).toEqual(['staticA', 'num']);
            expect(classDoc.members.length).toEqual(0);
        });
        it('should add additional declarations of a symbol onto the exportDoc', function () {
            processor.sourceFiles = ['multipleDeclarations.ts'];
            var docs = [];
            processor.$process(docs);
            var someThingDoc = docs.find(function (doc) { return doc.name === 'SomeThing'; });
            expect(someThingDoc.docType).toEqual('interface');
            expect(someThingDoc.content).toEqual('the constant doc');
            expect(someThingDoc.additionalDeclarations).toEqual([
                someThingDoc.symbol.getDeclarations()[0],
            ]);
        });
        it('should remove `index` from the end of module ids and names', function () {
            processor.sourceFiles = ['test/folder/index.ts'];
            var docs = [];
            processor.$process(docs);
            var moduleDoc = docs[0];
            expect(moduleDoc.id).toEqual('test/folder');
            expect(moduleDoc.name).toEqual('folder');
            var exportDoc = docs[1];
            expect(exportDoc.id).toEqual('test/folder/TestClass');
            expect(exportDoc.name).toEqual('TestClass');
        });
        it('should add each exportDoc to the exportSymbolsToDocsMap', function () {
            processor.sourceFiles = ['returnTypes.ts'];
            var docs = [];
            processor.$process(docs);
            var map = injector.get('exportSymbolsToDocsMap');
            expect(map.size).toEqual(2);
            map.forEach(function (doc, symbol) {
                expect(doc.symbol).toBe(symbol);
            });
        });
    });
    describe('ignoreExportsMatching', function () {
        it('should ignore exports that match items in the `ignoreExportsMatching` property', function () {
            processor.sourceFiles = ['ignoreExportsMatching.ts'];
            processor.ignoreExportsMatching = [/^_/];
            var docs = [];
            processor.$process(docs);
            var moduleDoc = docs[0];
            expect(moduleDoc.docType).toEqual('module');
            expect(moduleDoc.exports).toEqual([
                jasmine.objectContaining({ name: 'OKToExport' }),
                jasmine.objectContaining({ name: 'thisIsOK' }),
            ]);
        });
        it('should only ignore `___esModule` exports by default', function () {
            processor.sourceFiles = ['ignoreExportsMatching.ts'];
            var docs = [];
            processor.$process(docs);
            var moduleDoc = docs[0];
            expect(moduleDoc.docType).toEqual('module');
            expect(getNames(moduleDoc.exports)).toEqual([
                'OKToExport',
                '_thisIsPrivate',
                'thisIsOK',
            ]);
        });
    });
    describe('interfaces', function () {
        it('should mark optional properties', function () {
            processor.sourceFiles = ['interfaces.ts'];
            var docs = [];
            processor.$process(docs);
            var moduleDoc = docs[0];
            var exportedInterface = moduleDoc.exports[0];
            var member = exportedInterface.members[0];
            expect(member.name).toEqual('optionalProperty');
            expect(member.isOptional).toEqual(true);
        });
        it('should handle "call" type interfaces', function () {
            processor.sourceFiles = ['interfaces.ts'];
            var docs = [];
            processor.$process(docs);
            var moduleDoc = docs[0];
            var exportedInterface = moduleDoc.exports[0];
            var callMember = exportedInterface.members.find(function (member) { return member.isCallMember; });
            expect(callMember).toBeDefined();
            expect(callMember.parameters).toEqual(['param: T']);
            expect(callMember.type).toEqual('U');
            expect(callMember.typeParameters).toEqual('<T, U extends Findable<T>>');
            var newMember = exportedInterface.members.find(function (member) { return member.isNewMember; });
            expect(newMember).toBeDefined();
            expect(newMember.parameters).toEqual(['param: number']);
            expect(newMember.type).toEqual('MyInterface');
        });
    });
    describe('type aliases', function () {
        it('should find the correct type when there are multiple declarations', function () {
            processor.sourceFiles = ['type-aliases.ts'];
            var docs = [];
            processor.$process(docs);
            var typeAliasDoc = docs[2];
            expect(typeAliasDoc.docType).toEqual('type-alias');
            expect(typeAliasDoc.typeDefinition).toEqual('X<any>');
        });
        it('should include type parameters', function () {
            processor.sourceFiles = ['type-aliases.ts'];
            var docs = [];
            processor.$process(docs);
            var typeAliasDoc = docs.find(function (doc) { return doc.name === 'Parameterized'; });
            expect(typeAliasDoc.docType).toEqual('type-alias');
            expect(typeAliasDoc.typeParameters).toEqual('<T, R>');
        });
    });
    describe('exported functions', function () {
        it('should include type parameters', function () {
            processor.sourceFiles = ['functions.ts'];
            var docs = [];
            processor.$process(docs);
            var functionDoc = docs.find(function (doc) { return doc.name === 'foo'; });
            expect(functionDoc.docType).toEqual('function');
            expect(functionDoc.typeParameters).toEqual('<T, R>');
        });
    });
    describe('members', function () {
        describe('overloaded members', function () {
            it('should create a member doc for the "real" member, which includes an overloads property', function () {
                processor.sourceFiles = ['overloadedMembers.ts'];
                var docs = [];
                processor.$process(docs);
                var foo = docs.find(function (doc) { return doc.name === 'foo'; });
                expect(foo.parameters).toEqual(['num1: number|string', 'num2?: number']);
                var overloads = foo.overloads;
                expect(overloads.map(function (overload) { return overload.parameters; })).toEqual([
                    ['str: string'],
                    ['num1: number', 'num2: number'],
                ]);
            });
            it('should use the first declaration as the member doc if no overload has a body', function () {
                processor.sourceFiles = ['overloadedMembers.ts'];
                var docs = [];
                processor.$process(docs);
                var bar = docs.find(function (doc) { return doc.name === 'bar'; });
                expect(bar.overloads.length).toEqual(1);
                expect(bar.parameters).toEqual(['str: string']);
                expect(bar.overloads[0].parameters).toEqual([]);
            });
        });
        describe('overloaded constructors', function () {
            it('should create a member doc for the "real" constructor, which includes an overloads property', function () {
                processor.sourceFiles = ['overloadedMembers.ts'];
                var docs = [];
                processor.$process(docs);
                var foo = docs.find(function (doc) { return doc.name === 'constructor'; });
                expect(foo.parameters).toEqual(['x: string', 'y: number|string', 'z?: number']);
                var overloads = foo.overloads;
                expect(overloads.map(function (overload) { return overload.parameters; })).toEqual([
                    ['x: string', 'y: number'],
                    ['x: string', 'y: string', 'z: number'],
                ]);
            });
        });
        describe('ordering of members', function () {
            it('should order class members in order of appearance (by default)', function () {
                processor.sourceFiles = ['orderingOfMembers.ts'];
                var docs = [];
                processor.$process(docs);
                var classDoc = docs.find(function (doc) { return doc.docType === 'class'; });
                expect(classDoc.docType).toEqual('class');
                expect(getNames(classDoc.members)).toEqual([
                    'firstItem',
                    'otherMethod',
                    'doStuff',
                ]);
            });
            it('should not order class members if not sortClassMembers is false', function () {
                processor.sourceFiles = ['orderingOfMembers.ts'];
                processor.sortClassMembers = false;
                var docs = [];
                processor.$process(docs);
                var classDoc = docs.find(function (doc) { return doc.docType === 'class'; });
                expect(classDoc.docType).toEqual('class');
                expect(getNames(classDoc.members)).toEqual([
                    'firstItem',
                    'otherMethod',
                    'doStuff',
                ]);
            });
        });
        describe('return types', function () {
            it('should not throw if "declaration.initializer.expression.text" is undefined', function () {
                processor.sourceFiles = ['returnTypes.ts'];
                var docs = [];
                expect(function () { processor.$process(docs); }).not.toThrow();
            });
            it('should return the text of the type if initialized', function () {
                processor.sourceFiles = ['returnTypes.ts'];
                var docs = [];
                processor.$process(docs);
                var propDocs = docs.filter(function (doc) { return doc.name === 'someProp'; });
                expect(propDocs[0].type).toEqual('{\n' +
                    '    foo: \'bar\',\n' +
                    '  }');
                expect(propDocs[1].type).toEqual('Object.assign(this.someProp, {\n' +
                    '    bar: \'baz\'\n' +
                    '  })');
            });
        });
        describe('member modifiers', function () {
            it('should set the readOnly flag on readonly members', function () {
                processor.sourceFiles = ['memberModifiers.ts'];
                var docs = [];
                processor.$process(docs);
                var simpleProp = docs.filter(function (doc) { return doc.name === 'foo'; })[0];
                expect(simpleProp.isReadonly).toBeFalsy();
                var readonlyProp = docs.filter(function (doc) { return doc.name === 'bar'; })[0];
                expect(readonlyProp.isReadonly).toBeTruthy();
            });
        });
    });
    describe('strip namespaces', function () {
        it('should strip namespaces in return types', function () {
            processor.sourceFiles = ['stripNamespaces.ts'];
            var docs = [];
            processor.$process(docs);
            var functionDoc = docs.find(function (doc) { return doc.docType === 'function'; });
            expect(functionDoc.type).toEqual('IDirective');
        });
        it('should not strip ignored namespaces in return types', function () {
            var namespacesToInclude = injector.get('namespacesToInclude');
            namespacesToInclude.push('angular');
            processor.sourceFiles = ['stripNamespaces.ts'];
            var docs = [];
            processor.$process(docs);
            var functionDoc = docs.find(function (doc) { return doc.docType === 'function'; });
            expect(functionDoc.type).toEqual('angular.IDirective');
        });
        it('should cope with spread operator', function () {
            processor.sourceFiles = ['spreadParams.ts'];
            var docs = [];
            processor.$process(docs);
            var functionDoc = docs.find(function (doc) { return doc.docType === 'function'; });
            expect(functionDoc.parameters).toEqual(['...args: Array<any>']);
            expect(functionDoc.type).toEqual('void');
            var interfaceDoc = docs.find(function (doc) { return doc.docType === 'interface'; });
            expect(interfaceDoc.members.length).toEqual(2);
            var methodDoc = interfaceDoc.members[0];
            expect(methodDoc.parameters).toEqual(['...args: Array<any>']);
            expect(methodDoc.type).toEqual('void');
            var propertyDoc = interfaceDoc.members[1];
            expect(propertyDoc.type).toEqual('(...args: Array<any>) => void');
        });
    });
    describe('source file globbing patterns', function () {
        it('should work with include patterns', function () {
            processor.sourceFiles = [
                {
                    include: '*Module.ts',
                },
            ];
            var docs = [];
            processor.$process(docs);
            var moduleDocs = docs.filter(function (doc) { return doc.docType === 'module'; });
            expect(moduleDocs.length).toBe(2);
            expect(moduleDocs[0].name).toEqual('privateModule');
            expect(moduleDocs[1].name).toEqual('publicModule');
        });
        it('should work with include/exclude patterns', function () {
            processor.sourceFiles = [
                {
                    exclude: 'public*.ts',
                    include: '*Module.ts',
                },
            ];
            var docs = [];
            processor.$process(docs);
            var moduleDoc = docs[0];
            expect(moduleDoc.name).toEqual('privateModule');
        });
    });
});
function getNames(collection) {
    return collection.map(function (item) { return item.name; });
}
//# sourceMappingURL=index.spec.js.map