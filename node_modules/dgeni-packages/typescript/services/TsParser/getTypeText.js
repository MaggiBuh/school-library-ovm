"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var typescript_1 = require("typescript");
function getTypeText(type, namespacesToInclude) {
    if (type.kind === typescript_1.SyntaxKind.TypeReference) {
        // we have a type reference, so recurse down to find the unqualified name
        return getTypeReferenceText(type, namespacesToInclude);
    }
    else {
        // we have a straightforward type
        return type.getText();
    }
}
exports.getTypeText = getTypeText;
function getTypeReferenceText(typeRef, namespacesToInclude) {
    var typeName = getUnqualifiedName(typeRef.typeName, namespacesToInclude);
    if (typeRef.typeArguments) {
        // The type is a generic so we must also get the unqualified names of each type
        var typeArguments = typeRef.typeArguments.map(function (typeArgument) { return getTypeText(typeArgument, namespacesToInclude); });
        return typeName + "<" + typeArguments.join(', ') + ">";
    }
    return typeName;
}
function getUnqualifiedName(name, namespacesToInclude) {
    var nameParts = [];
    while (name.kind === typescript_1.SyntaxKind.QualifiedName) {
        var qualification = name.left.getText();
        if (namespacesToInclude.indexOf(qualification) !== -1) {
            nameParts.push(qualification);
        }
        name = name.right;
    }
    nameParts.push(name.getText());
    return nameParts.join('.');
}
//# sourceMappingURL=getTypeText.js.map